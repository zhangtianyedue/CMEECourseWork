Starting testing for Tianye, Week3

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 1.49 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: .git, week1, Week2, Feedback, week3

Found the following files in parent directory: README.log, README.md, .DS_Store

Checking for key files in parent directory...

.gitignore missing!

Found README in parent directory, named: README.log

Printing contents of README.log:

**********************************************************************

**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week2, week1, week3

The Week3 directory will be tested 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Testing WEEK3...

Found the following directories: sandbox, results, data, code

Found the following files: README.md, .DS_Store

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************

# Week 3 Coursework

This repository contains the individual coursework for Week 3, focusing on two specific tasks: analyzing tree species (particularly oaks) and aligning DNA sequences. Below is an overview of the two scripts, including the input data they require and the output files they generate.

## Scripts Overview

### 1. `oaks_debugme.py`
This script reads a CSV file of tree species and identifies which species belong to the Quercus genus (oak trees). It processes each row and filters out non-oak species, then writes the filtered data to an output file. 

- **Input**: `../data/TestOaksData.csv` (a CSV file containing genus and species information).
- **Output**: `../results/oaks_debugme_results.csv` (a CSV file listing all oak species from the input data).

The main functionality of this script is to determine if a given species belongs to the "Quercus" genus using the `is_an_oak` function, which checks whether the genus name starts with 'quercus'.

### 2. `align_seqs_fasta.py`
This script aligns two DNA sequences and finds the best possible alignment based on the number of matching bases. It reads the DNA sequences from FASTA files, aligns them at different starting points, and calculates a score for each alignment. The alignment with the highest score is then saved to an output file.

- **Input**: Two FASTA files containing DNA sequences, passed as command-line arguments or defaulted to `../data/407228326.fasta` and `../data/407228412.fasta`.
- **Output**: `../results/DNA_seq.txt` (a file containing the best alignment and its corresponding score).

The script uses the `calculate_score` function to align the sequences and compute the number of matches at various positions.

## Data and Results

- All input data for these scripts can be found in the `data` folder.
- The results generated by the scripts will be saved in the `results` folder.

## Usage

To run the scripts, make sure your terminal is set to the `code` directory, as the scripts use relative paths to access data and output files.

### Example:

```bash
$ cd code
$ python3 oaks_debugme.py
$ python3 align_seqs_fasta.py

**********************************************************************

Results directory is empty - good! 

Found 2 code files: align_seqs_fasta.py, oaks_debugme.py

Found the following extra files: README.md
======================================================================
Testing script/code files...

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:

**********************************************************************
"""
Script to align two DNA sequences and find the best alignment based on matching bases.

This script reads two DNA sequences from FASTA files (or defaults to predefined file paths if none are provided),
compares them by aligning one sequence to the other at different starting points, and calculates an alignment score
based on the number of matching bases. The script identifies the best alignment (i.e., the alignment with the highest score)
and writes the result to a file.


Functions:
    - read_fasta: Reads a DNA sequence from a FASTA file, ignoring the header line.
    - calculate_score: Aligns two sequences starting from a specified position and returns the score based on matching bases.

Workflow:
    1. The script reads two DNA sequences from the command line or uses default files.
    2. It identifies the longer sequence and aligns the shorter one at various starting points.
    3. For each alignment, it computes a score based on how many bases match.
    4. It determines the alignment with the highest score and saves the result to an output file.

Input:
    - Two FASTA files containing DNA sequences, passed as command-line arguments or predefined file paths.
      (FASTA files should be in plain text format, without `.rtf` or other extensions.)

Output:
    - The best alignment and corresponding score are written to '../Results/DNA_seq.txt'.
    - Alignment details are printed to the terminal.

Author: Saskia Pearce (sp621@imperial.ac.uk)
Version: 3.9
"""

#input file name and seq1.fasta seq2.fasta 

import sys 
import os

# Define the base directory for your data (relative path)
base_dir = "../data/"

# Check if command-line arguments are provided
if len(sys.argv) >= 3: 
    # Use the paths provided by command-line arguments
    seq1  = os.path.join(base_dir, sys.argv[1])
    seq2  = os.path.join(base_dir, sys.argv[2])
else:
    # Use default paths if no arguments are provided
    seq1  = os.path.join(base_dir, "407228326.fasta")
    seq2  = os.path.join(base_dir, "407228412.fasta")

def read_fasta(filename): 
    with open(filename, 'r') as f: 
        lines = f.readlines()
    sequence = ''.join([line.strip() for line in lines if not line.startswith(">")])
    return sequence 

seq1 = read_fasta(seq1)
seq2 = read_fasta(seq2)

l1 = len(seq1) #assign longested sequence from file 
l2 = len(seq2) 
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """
    Calculate the alignment score between two DNA sequences starting from a specified position.

    This function aligns a portion of sequence `s2` with sequence `s1` starting at the given 
    `startpoint`. It compares the bases of both sequences, adds to the score if they match, 
    and prints the alignment visually with '*' indicating a match and '-' indicating a mismatch.

    Args:
        s1 (str): The first DNA sequence (usually the longer one).
        s2 (str): The second DNA sequence (usually the shorter one to be aligned with `s1`).
        l1 (int): The length of sequence `s1`.
        l2 (int): The length of sequence `s2`.
        startpoint (int): The starting position in `s1` where the alignment with `s2` begins.

    Returns:
        int: The alignment score representing the number of matching bases between `s1` and `s2`.

    Example:
        >>> calculate_score("AGCTGAC", "GCT", 7, 3, 1)
        .***
        .GCT
        AGCTGAC
        3
    """
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)      #startpoitn has to shift up every time       
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

my_best_align = None
my_best_score = -1

with open('../Results/DNA_seq.txt', 'w') as f:
    for i in range(l1):
        score = calculate_score(s1, s2, l1, l2, i)
        if score > my_best_score:
            my_best_align = "." * i + s2
            my_best_score = score
    f.write("Best alignment:\n")
    f.write(f"{my_best_align}\n{s1}\n")
    f.write(f"Best score: {my_best_score}\n")

print(my_best_align)
print(s1)
print("Best score:", my_best_score)




#results = '../results/alignment_results.txt'

# now try to find the best match (highest score) for the two sequences
#my_best_align = None
#my_best_score = -1 #alignment will always be higher than this starting score

#f = open('../Results/DNA_seq.txt','w')
#for i in range(l1): # Note that you just take the last alignment with the highest score
    #z = calculate_score(s1, s2, l1, l2, i) #arguement in the file 
    #if z > my_best_score:
        #my_best_align = "." * i + s2 # think about what this is doing!
        #my_best_score = z 
        #f.write("Best alignment:\n")
        #f.write(f"{my_best_align}\n{s1}\n")
        #f.write(f"Best score: {my_best_score}\n")

#f.close()

#print(my_best_align)
#print(s1)
#print("Best score:", my_best_score) # best score printed

# assigning seq1.fasta (first argument)






# assigning seq2.fasta (second arguement)




**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2024-25/Coursework/StudentRepos/TianyeZhang_tz124/week3/code/align_seqs_fasta.py", line 123, in <module>
    with open('../Results/DNA_seq.txt', 'w') as f:
FileNotFoundError: [Errno 2] No such file or directory: '../Results/DNA_seq.txt'

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:

**********************************************************************
"""
This module processes a CSV file of tree species, checks whether each species belongs to the 'Quercus' genus (oak trees),
and writes the oak species to an output CSV file, while filtering out duplicate entries.

Functions:
    - is_an_oak(name): Determines if a species belongs to the Quercus genus (oak trees).
    - main(argv): Reads input CSV data, processes the species list, and writes oaks to the results file.
    
Module-Level:
    The script performs the following tasks:
    1. Reads a CSV file ('../data/TestOaksData.csv') containing tree species data with 'Genus' and 'Species' columns.
    2. Identifies oak species (those from the 'Quercus' genus) and writes them into a new CSV file ('../results/oaks_debugme_results.csv').
    3. Ensures there are no duplicate oak species in the output.
    4. Handles both the presence and absence of headers in the input file.

    The script also includes unit tests within the `is_an_oak` function, which can be executed via Python's doctest module.

Usage:
    Run the script from the command line or from within another Python program.
    Example:
        $ python oaks_debugme.py
"""

import csv
import sys
import doctest

#==================================================================================================

# Define the function `is_an_oak`
def is_an_oak(name):
    """
    Determines if a tree species belongs to the Quercus genus (oak trees).
    
    Args:
        name (str): The name of the genus to check (usually the genus of a tree).
    
    Returns:
        bool: True if the species belongs to the Quercus genus, otherwise False.
    
    This function converts the input string to lowercase, checks if the name starts with 'quercus', and ensures
    that either the name exactly matches 'quercus' or the next character after 'quercus' is a space.
    
    Examples:
        >>> is_an_oak('Fagus sylvatica')
        False
        >>> is_an_oak('Quercus robur')
        True
        >>> is_an_oak('quercus ROBUR')
        True
        >>> is_an_oak('Quercuss robur')
        False
        >>> is_an_oak('Quercus')
        True
        >>> is_an_oak(' Quercus robur')
        False
    """
    # Convert the name to lowercase for case-insensitive matching
    name = name.lower()
    # Check if the name starts with 'quercus' and either matches exactly or has a space after 'quercus'
    return name.startswith('quercus') and (len(name) == len('quercus') or name[len('quercus')] == ' ')

#==================================================================================================

def main(argv):
    """
    Main function that processes a CSV file containing genus and species data, identifies oak species,
    and writes the results to an output CSV file.
    
    Args:
        argv (list): Command line arguments passed to the script (though not used directly in this implementation).
    
    Steps:
        1. Reads the input CSV file ('../data/TestOaksData.csv') containing tree species information.
        2. Identifies species that belong to the Quercus genus using the `is_an_oak` function.
        3. Writes oak species into the output file ('../results/oaks_debugme_results.csv'), avoiding duplicates.
        4. Handles input files with or without headers. If headers exist, they are written to the output.

    Input:
        The input CSV file should have two columns: 'Genus' and 'Species'.
    
    Output:
        The results CSV file will contain oak species filtered by genus and species.

    Returns:
        int: Status code (0 if successful).
    
    Example usage:
        $ python oaks_debugme.py
    
    Notes:
        - The input file '../data/TestOaksData.csv' is expected to exist and be properly formatted.
        - This function handles duplicates and only outputs unique oak species.
    """
    # Open the input CSV file with tree species data and prepare to write results to another CSV file
    f = open('../data/TestOaksData.csv', 'r')  # Input file
    g = open('../results/oaks_debugme_results.csv', 'w')  # Output file
    taxa = csv.reader(f)  # Read the input file
    csvwrite = csv.writer(g)  # Prepare to write to the output file
    oaks = set()  # Set to store unique oak species names

    # Skip the first row (header), if present, and write it to the output file
    header = next(taxa)
    if header[0].strip().lower() == 'genus' and header[1].strip().lower() == 'species':
        print("Skipping header row...")  # Inform that the header row is being skipped
        csvwrite.writerow(header)  # Write the header to the output file
    else:
        taxa = [header] + list(taxa)  # If no header row, add it back to the remaining rows
        header = ["Genus", "Species"]
        csvwrite.writerow(header)  # Write default header row

    # Iterate over each row and check if it belongs to the Quercus genus (oak trees)
    for row in taxa:
        print(row)
        print("The genus is: ", row[0])

        # If it's an oak, and not a duplicate, write it to the results file
        if is_an_oak(row[0]):
            rowfullname = row[0] + " " + row[1]
            if rowfullname not in oaks:  # Prevent duplicates
                print(rowfullname, " is an oak! \n")
                csvwrite.writerow([row[0], row[1]])  # Write the row to the results file
                oaks.add(rowfullname)  # Add the oak species to the set
        else:
            rowfullname = row[0] + " " + row[1]
            print(rowfullname, "is not an oak! \n")  # If not an oak, display message and skip

    return 0  # Return 0 to indicate successful execution

#==================================================================================================

if __name__ == "__main__":
    """
    Calls the main function and runs the doctest module to test the is_an_oak function.
    The script will exit with status code 0 upon successful execution.
    """
    import doctest
    doctest.testmod()  # Run doctests to validate the is_an_oak function
    status = main(sys.argv)  # Run the main function
    sys.exit(status)  # Exit the program with the returned status






**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Output (only first 500 characters): 


**********************************************************************
Skipping header row...
['Quercus', ' robur']
The genus is:  Quercus
Quercus  robur  is an oak! 

['Fraxinus', ' excelsior']
The genus is:  Fraxinus
Fraxinus  excelsior is not an oak! 

['Pinus', ' sylvestris']
The genus is:  Pinus
Pinus  sylvestris is not an oak! 

['Quercus', ' cerris']
The genus is:  Quercus
Quercus  cerris  is an oak! 

['Quercus', ' petraea']
The genus is:  Quercus
Quercus  petraea  is an oak! 


**********************************************************************

Code ran without errors

Time consumed = 0.04892s

======================================================================
======================================================================
Finished running scripts

Ran into 1 errors

======================================================================
======================================================================

FINISHED LOGGING

