import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom scipy.optimize import curve_fitimport os# Read the datadata = pd.read_csv("../results/Cleaned_LogisticGrowthData.csv")data["Unique_ID"] = data["Unique_ID"].astype(str)# Define nonlinear modelsdef gompertz_model(t, log_r_max, log_K, log_N_0, log_t_lag):    r_max, K, N_0, t_lag = np.exp([log_r_max, log_K, log_N_0, log_t_lag])    return N_0 + (K - N_0) * np.exp(-np.exp(r_max * np.exp(1) * (t_lag - t) / ((K - N_0) * np.log(10)) + 1))def logistic_model(t, log_r_max, log_K, log_N_0):    r_max, K, N_0 = np.exp([log_r_max, log_K, log_N_0])    return (N_0 * K * np.exp(r_max * t)) / (K + N_0 * (np.exp(r_max * t) - 1))def richards_model(t, log_r_max, log_K, log_N_0, log_v):    r_max, K, N_0, v = np.exp([log_r_max, log_K, log_N_0, log_v])    return K / ((1 + ((K / N_0 - 1) * np.exp(-r_max * t))) ** (1 / v))# Generate a shortened IDdef generate_short_id(index):    return f"id_{index + 1}"# Create output directoryoutput_folder = "../results/png_python"os.makedirs(output_folder, exist_ok=True)# Iterate through all Unique_IDsfor index, unique_id in enumerate(data["Unique_ID"].unique()):    subset = data[data["Unique_ID"] == unique_id].sort_values("Time")        # Skip IDs with too few data points    if len(subset) < 5:        print(f"Skipping {unique_id} due to insufficient data points.")        continue        # Compute time split point (median)    median_time = subset["Time"].median()    subset1 = subset[subset["Time"] <= median_time]    subset2 = subset[subset["Time"] > median_time]        # Generate short ID    short_id = generate_short_id(index)        # Define fitting models    models = {        "Linear": lambda t, a, b: a * t + b,        "Quadratic": lambda t, a, b, c: a * t**2 + b * t + c,        "Gompertz": gompertz_model,        "Logistic": logistic_model,        "Richards": richards_model    }        # Store fitted models    fitted_models = {}        # Iterate through both subsets for fitting    for part_index, sub in enumerate([subset1, subset2]):        if len(sub) < 3:            continue  # Skip subsets with too few data points                # Compute initial parameters        K_start = np.log(max(sub["PopBio"].max() * 1.1, 1e-3))        t_lag_start = np.log(max(sub["Time"].median(), 1e-3))        r_max_start = np.log(max(np.gradient(sub["PopBio"]).max(), 1e-3))        v_start = np.log(1)  # v parameter required for Richards model                for model_name, model_func in models.items():            try:                if model_name == "Linear":                    popt, _ = curve_fit(model_func, sub["Time"], sub["PopBio"], maxfev=20000)                    fitted_models[f"{model_name}_P{part_index+1}"] = (model_func, popt)                                elif model_name == "Quadratic":                    popt, _ = curve_fit(model_func, sub["Time"], sub["PopBio"], maxfev=20000)                    fitted_models[f"{model_name}_P{part_index+1}"] = (model_func, popt)                                elif model_name == "Gompertz":                    popt, _ = curve_fit(model_func, sub["Time"], sub["PopBio"],                                        p0=[r_max_start, K_start, np.log(sub["PopBio"].min()), t_lag_start],                                        bounds=([-10, -10, -10, -10], [10, 10, 10, 10]), maxfev=20000)                    fitted_models[f"Gompertz_P{part_index+1}"] = (model_func, popt)                                elif model_name == "Logistic":                    popt, _ = curve_fit(model_func, sub["Time"], sub["PopBio"],                                        p0=[r_max_start, K_start, np.log(sub["PopBio"].min())],                                        bounds=([-10, -10, -10], [10, 10, 10]), maxfev=20000)                    fitted_models[f"Logistic_P{part_index+1}"] = (model_func, popt)                                elif model_name == "Richards":                    popt, _ = curve_fit(model_func, sub["Time"], sub["PopBio"],                                        p0=[r_max_start, K_start, np.log(sub["PopBio"].min()), v_start],                                        bounds=([-10, -10, -10, -10], [10, 10, 10, 10]), maxfev=20000)                    fitted_models[f"Richards_P{part_index+1}"] = (model_func, popt)                        except Exception as e:                print(f"{model_name} model failed for {short_id} (Part {part_index+1}): {e}")        # Plot results    plt.figure(figsize=(8, 6))    plt.scatter(subset["Time"], subset["PopBio"], color="black", label="Data", alpha=0.7)        # Generate time range    time_range = np.linspace(subset["Time"].min(), subset["Time"].max(), 100)        # Plot each successfully fitted model curve    for model_name, (model_func, popt) in fitted_models.items():        plt.plot(time_range, model_func(time_range, *popt), label=model_name)        # Add time split dashed line    plt.axvline(x=median_time, color='gray', linestyle='dashed', linewidth=1, label="Time Split")        # **Modified: Simplified title**    plt.title(f"Growth Curve - {short_id}")        # Set labels and legend    plt.xlabel("Time")    plt.ylabel("PopBio")    plt.legend()        # **Ensure y-axis starts from 0**    max_y = max(subset["PopBio"].max(), 1)    plt.ylim(0, max_y * 1.1)        # **Save the figure**    file_path = os.path.join(output_folder, f"{short_id}_growth_curve.png")    plt.savefig(file_path)    plt.close()    print(f"Saved: {file_path}")