import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom scipy.optimize import curve_fitimport os# Read the datadata = pd.read_csv("../results/Cleaned_LogisticGrowthData.csv")data["Unique_ID"] = data["Unique_ID"].astype(str)# Define the modelsdef gompertz_model(t, log_r_max, log_K, log_N_0, log_t_lag):    r_max = np.exp(log_r_max)    K = np.exp(log_K)    N_0 = np.exp(log_N_0)    t_lag = np.exp(log_t_lag)    return N_0 + (K - N_0) * np.exp(-np.exp(r_max * np.exp(1) * (t_lag - t) / ((K - N_0) * np.log(10)) + 1))def logistic_model(t, log_r_max, log_K, log_N_0):    r_max = np.exp(log_r_max)    K = np.exp(log_K)    N_0 = np.exp(log_N_0)    return (N_0 * K * np.exp(r_max * t)) / (K + N_0 * (np.exp(r_max * t) - 1))def richards_model(t, log_r_max, log_K, log_N_0, log_v):    r_max = np.exp(log_r_max)    K = np.exp(log_K)    N_0 = np.exp(log_N_0)    v = np.exp(log_v)    return K / ((1 + ((K/N_0 - 1) * np.exp(-r_max * t))) ** (1/v))# Generate a shortened IDdef generate_short_id(index):    return f"id_{index + 1}"# Create output directoryoutput_folder = "../results/png_python"os.makedirs(output_folder, exist_ok=True)# Iterate over all Unique_IDsfor index, unique_id in enumerate(data["Unique_ID"].unique()):    subset = data[data["Unique_ID"] == unique_id]        # Ensure data is sorted by time    subset = subset.sort_values("Time")    # Skip if there are fewer than 5 data points    if len(subset) < 5:        print(f"Skipping {unique_id} due to insufficient data points.")        continue        # Compute initial parameters    K_start = np.log(max(subset["PopBio"].max() * 1.1, 1e-3))    t_lag_start = np.log(max(subset["Time"].median(), 1e-3))    r_max_start = np.log(max(np.gradient(subset["PopBio"]).max(), 1e-3))    v_start = np.log(1)  # v parameter needed for Richards model    # Generate short ID    short_id = generate_short_id(index)    # Define the fitting models    models = {        "Linear": lambda t, a, b: a * t + b,        "Quadratic": lambda t, a, b, c: a * t**2 + b * t + c,        "Gompertz": gompertz_model,        "Logistic": logistic_model,        "Richards": richards_model    }    # Store fitted models    fitted_models = {}    # Perform curve fitting    for model_name, model_func in models.items():        try:            if model_name == "Linear":                popt, _ = curve_fit(model_func, subset["Time"], subset["PopBio"], maxfev=20000)            elif model_name == "Quadratic":                popt, _ = curve_fit(model_func, subset["Time"], subset["PopBio"], maxfev=20000)            elif model_name == "Gompertz":                popt, _ = curve_fit(model_func, subset["Time"], subset["PopBio"],                                    p0=[r_max_start, K_start, np.log(subset["PopBio"].min()), t_lag_start],                                    bounds=([-10, -10, -10, -10], [10, 10, 10, 10]), maxfev=20000)            elif model_name == "Logistic":                popt, _ = curve_fit(model_func, subset["Time"], subset["PopBio"],                                    p0=[r_max_start, K_start, np.log(subset["PopBio"].min())],                                    bounds=([-10, -10, -10], [10, 10, 10]), maxfev=20000)            elif model_name == "Richards":                popt, _ = curve_fit(model_func, subset["Time"], subset["PopBio"],                                    p0=[r_max_start, K_start, np.log(subset["PopBio"].min()), v_start],                                    bounds=([-10, -10, -10, -10], [10, 10, 10, 10]), maxfev=20000)            # Store the fitted function            fitted_models[model_name] = lambda t, func=model_func, p=popt: func(t, *p)        except Exception as e:            print(f"{model_name} model failed for {short_id}: {e}")    # Plot the data and fitted models    plt.figure(figsize=(8, 6))    plt.scatter(subset["Time"], subset["PopBio"], color="black", label="Data", alpha=0.7)    # Generate time range for plotting    time_range = np.linspace(subset["Time"].min(), subset["Time"].max(), 100)    # Plot each successfully fitted model    for model_name, model_func in fitted_models.items():        plt.plot(time_range, model_func(time_range), label=model_name)    # **Modified: Simplified title**    plt.title(f"Growth Curve - {short_id}")    # Set labels and legend    plt.xlabel("Time")    plt.ylabel("PopBio")    plt.legend()    # **Ensure y-axis starts from 0**    max_y = max(subset["PopBio"].max(), 1)    plt.ylim(0, max_y * 1.1)    # **Save the figure**    file_path = os.path.join(output_folder, f"{short_id}_growth_curve.png")    plt.savefig(file_path)    plt.close()    print(f"Saved: {file_path}")